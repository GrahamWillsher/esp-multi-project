#!/usr/bin/env python3
"""
Battery and Inverter Type Mapping Generator

This script extracts battery and inverter type information from the Battery Emulator
source code and generates C++ code for the receiver application.

Usage:
    python3 generate_type_mappings.py <battery_emulator_path> <output_path>

Example:
    python3 generate_type_mappings.py \
        ../ESPnowtransmitter2/espnowtransmitter2/src/battery_emulator/battery/BATTERIES.cpp \
        ../espnowreciever_2/lib/webserver/api/type_mappings_generated.h
"""

import re
import sys
from pathlib import Path


def extract_battery_types(batteries_cpp_path):
    """Extract battery types from BATTERIES.cpp"""
    types = {}
    
    try:
        with open(batteries_cpp_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Find the name_for_battery_type function
        pattern = r'case BatteryType::(\w+):\s+return "(.+?)";'
        matches = re.findall(pattern, content)
        
        # Map enum names to numeric IDs (based on order in enum)
        enum_mapping = {
            'None': 0,
            'BmwI3': 2,
            'BmwIX': 3,
            'BoltAmpera': 4,
            'BydAtto3': 5,
            'CellPowerBms': 6,
            'Chademo': 7,
            'CmfaEv': 8,
            'Foxess': 9,
            'GeelyGeometryC': 10,
            'OrionBms': 11,
            'Sono': 12,
            'StellantisEcmp': 13,
            'ImievCZeroIon': 14,
            'JaguarIpace': 15,
            'KiaEGmp': 16,
            'KiaHyundai64': 17,
            'KiaHyundaiHybrid': 18,
            'Meb': 19,
            'Mg5': 20,
            'NissanLeaf': 21,
            'Pylon': 22,
            'DalyBms': 23,
            'RjxzsBms': 24,
            'RangeRoverPhev': 25,
            'RenaultKangoo': 26,
            'RenaultTwizy': 27,
            'RenaultZoe1': 28,
            'RenaultZoe2': 29,
            'SantaFePhev': 30,
            'SimpBms': 31,
            'TeslaModel3Y': 32,
            'TeslaModelSX': 33,
            'TestFake': 34,
            'VolvoSpa': 35,
            'VolvoSpaHybrid': 36,
            'MgHsPhev': 37,
            'SamsungSdiLv': 38,
            'HyundaiIoniq28': 39,
            'Kia64FD': 40,
            'RelionBattery': 41,
            'RivianBattery': 42,
            'CmpSmartCar': 45,
            'FordMachE': 44,
            'MaxusEV80': 46,
            'BmwPhev': 43,
        }
        
        for enum_name, display_name in matches:
            if enum_name in enum_mapping:
                types[enum_mapping[enum_name]] = display_name
        
        return types
    except Exception as e:
        print(f"Error extracting battery types: {e}", file=sys.stderr)
        return {}


def extract_inverter_protocols(batteries_cpp_path):
    """Extract inverter protocols from datalayer"""
    # For now, return hardcoded list based on Battery Emulator protocol names
    protocols = {
        0: "None",
        1: "Afore battery over CAN",
        2: "BYD Battery-Box Premium HVS over CAN Bus",
        3: "BYD 11kWh HVM battery over Modbus RTU",
        4: "Ferroamp Pylon battery over CAN bus",
        5: "FoxESS compatible HV2600/ECS4100 battery",
        6: "Growatt High Voltage protocol via CAN",
        7: "Growatt Low Voltage (48V) protocol via CAN",
        8: "Growatt WIT compatible battery via CAN",
        9: "BYD battery via Kostal RS485",
        10: "Pylontech HV battery over CAN bus",
        11: "Pylontech LV battery over CAN bus",
        12: "Schneider V2 SE BMS CAN",
        13: "SMA compatible BYD H",
        14: "SMA compatible BYD Battery-Box HVS",
        15: "SMA Low Voltage (48V) protocol via CAN",
        16: "SMA Tripower CAN",
        17: "Sofar BMS (Extended) via CAN, Battery ID",
        18: "SolaX Triple Power LFP over CAN bus",
        19: "Solxpow compatible battery",
        20: "Sol-Ark LV protocol over CAN bus",
        21: "Sungrow SBRXXX emulation over CAN bus",
    }
    return protocols


def generate_cpp_header(battery_types, inverter_types):
    """Generate C++ header file with type mappings"""
    
    header = '''// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// Generated by generate_type_mappings.py
// Source: Battery Emulator BATTERIES.cpp
// 
// This file is regenerated during build to ensure battery and inverter types
// stay synchronized with the Battery Emulator source code.

#ifndef TYPE_MAPPINGS_GENERATED_H
#define TYPE_MAPPINGS_GENERATED_H

#include <stdint.h>

// ═══════════════════════════════════════════════════════════════════════
// BATTERY TYPE MAPPINGS
// ═══════════════════════════════════════════════════════════════════════

static const struct {
    uint8_t id;
    const char* name;
} BATTERY_TYPES_MAP[] = {
'''
    
    for battery_id in sorted(battery_types.keys()):
        header += f'    {{{battery_id}, "{battery_types[battery_id]}"}},\n'
    
    header += f'''    {{255, nullptr}}  // Sentinel
}};
#define BATTERY_TYPES_COUNT {len(battery_types)}

// ═══════════════════════════════════════════════════════════════════════
// INVERTER TYPE MAPPINGS
// ═══════════════════════════════════════════════════════════════════════

static const struct {
    uint8_t id;
    const char* name;
} INVERTER_TYPES_MAP[] = {
'''
    
    for inverter_id in sorted(inverter_types.keys()):
        header += f'    {{{inverter_id}, "{inverter_types[inverter_id]}"}},\n'
    
    header += f'''    {{255, nullptr}}  // Sentinel
}};
#define INVERTER_TYPES_COUNT {len(inverter_types)}

#endif  // TYPE_MAPPINGS_GENERATED_H
'''
    
    return header


def main():
    if len(sys.argv) < 3:
        print("Usage: python3 generate_type_mappings.py <battery_emulator_path> <output_path>")
        print("Example: python3 generate_type_mappings.py ../ESPnowtransmitter2/.../BATTERIES.cpp ../espnowreciever_2/.../type_mappings_generated.h")
        sys.exit(1)
    
    batteries_cpp = Path(sys.argv[1])
    output_file = Path(sys.argv[2])
    
    if not batteries_cpp.exists():
        print(f"Error: File not found: {batteries_cpp}", file=sys.stderr)
        sys.exit(1)
    
    print(f"Reading battery types from: {batteries_cpp}")
    battery_types = extract_battery_types(str(batteries_cpp))
    
    print(f"Found {len(battery_types)} battery types")
    for bat_id in sorted(battery_types.keys()):
        print(f"  {bat_id}: {battery_types[bat_id]}")
    
    print("Extracting inverter types...")
    inverter_types = extract_inverter_protocols(str(batteries_cpp))
    print(f"Found {len(inverter_types)} inverter types")
    
    print(f"Generating C++ header: {output_file}")
    header_content = generate_cpp_header(battery_types, inverter_types)
    
    output_file.parent.mkdir(parents=True, exist_ok=True)
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(header_content)
    
    print(f"✓ Successfully generated: {output_file}")


if __name__ == "__main__":
    main()
