#include "settings_html.h"
#include <Arduino.h>
#include <string>
#include <unordered_map>
#include <functional>
#include "../../../src/communication/contactorcontrol/comm_contactorcontrol.h"
#include "../../../src/communication/equipmentstopbutton/comm_equipmentstopbutton.h"
#include "../../charger/CHARGERS.h"
#include "../../communication/can/comm_can.h"
#include "../../communication/nvm/comm_nvm.h"
#include "../../datalayer/datalayer.h"
#include "LittleFS.h"
#include "html_escape.h"
#include "index_html.h"
#include "src/battery/BATTERIES.h"
#include "src/inverter/INVERTERS.h"
#include "../../battery/Shunt.h"
#include "../wifi/wifi.h"
#include "../hal/hw_lilygo_t_connect_pro.h"

extern bool settingsUpdated;

// Helper function to read file content from LittleFS
String readFileFromLittleFS(const char* filename) {
  File file = LittleFS.open(filename, "r");
  if (!file) {
    return String("<!-- Error: Could not open file: ") + filename + " -->";
  }

  String content = file.readString();
  file.close();
  return content;
}

template <typename E>
constexpr auto to_underlying(E e) noexcept {
  return static_cast<std::underlying_type_t<E>>(e);
}

template <typename EnumType>
std::vector<EnumType> enum_values() {
  static_assert(std::is_enum_v<EnumType>, "Template argument must be an enum type.");

  constexpr auto count = to_underlying(EnumType::Highest);
  std::vector<EnumType> values;
  for (int i = 1; i < count; ++i) {
    values.push_back(static_cast<EnumType>(i));
  }
  return values;
}

template <typename EnumType, typename Func>
std::vector<std::pair<String, EnumType>> enum_values_and_names(Func name_for_type,
                                                               const EnumType* noneValue = nullptr) {
  auto values = enum_values<EnumType>();

  std::vector<std::pair<String, EnumType>> pairs;

  for (auto& type : values) {
    auto name = name_for_type(type);
    if (name != nullptr) {
      pairs.push_back(std::pair(String(name), type));
    }
  }

  std::sort(pairs.begin(), pairs.end(), [](const auto& a, const auto& b) { return a.first < b.first; });

  if (noneValue) {
    pairs.insert(pairs.begin(), std::pair(name_for_type(*noneValue), *noneValue));
  }

  return pairs;
}

template <typename TEnum, typename Func>
String options_for_enum_with_none(TEnum selected, Func name_for_type, TEnum noneValue) {
  String options;
  TEnum none = noneValue;
  auto values = enum_values_and_names<TEnum>(name_for_type, &none);
  for (const auto& [name, type] : values) {
    options +=
        ("<option value=\"" + String(static_cast<int>(type)) + "\"" + (selected == type ? " selected" : "") + ">");
    options += name;
    options += "</option>";
  }
  return options;
}

template <typename TEnum, typename Func>
String options_for_enum(TEnum selected, Func name_for_type) {
  String options;
  auto values = enum_values_and_names<TEnum>(name_for_type, nullptr);
  for (const auto& [name, type] : values) {
    if (name[0] == '\0')
      continue;  // Don't show blank options
    options +=
        ("<option value=\"" + String(static_cast<int>(type)) + "\"" + (selected == type ? " selected" : "") + ">");
    options += name;
    options += "</option>";
  }
  return options;
}

template <typename TMap>
String options_from_map(int selected, const TMap& value_name_map) {
  String options;
  for (const auto& [value, name] : value_name_map) {
    options += "<option value=\"" + String(value) + "\"";
    if (selected == value) {
      options += " selected";
    }
    options += ">";
    options += name;
    options += "</option>";
  }
  return options;
}

static const std::map<int, String> led_modes = {{0, "Classic"}, {1, "Energy Flow"}, {2, "Heartbeat"}};

static const std::map<int, String> tesla_countries = {
    {21843, "US (USA)"},     {17217, "CA (Canada)"},  {18242, "GB (UK & N Ireland)"},
    {17483, "DK (Denmark)"}, {17477, "DE (Germany)"}, {16725, "AU (Australia)"}};

static const std::map<int, String> tesla_mapregion = {
    {8, "ME (Middle East)"}, {2, "NONE"},       {3, "CN (China)"},     {6, "TW (Taiwan)"}, {5, "JP (Japan)"},
    {0, "US (USA)"},         {7, "KR (Korea)"}, {4, "AU (Australia)"}, {1, "EU (Europe)"}};

static const std::map<int, String> tesla_chassis = {{0, "Model S"}, {1, "Model X"}, {2, "Model 3"}, {3, "Model Y"}};

static const std::map<int, String> tesla_pack = {{0, "50 kWh"}, {2, "62 kWh"}, {1, "74 kWh"}, {3, "100 kWh"}};

const char* name_for_button_type(STOP_BUTTON_BEHAVIOR behavior) {
  switch (behavior) {
    case STOP_BUTTON_BEHAVIOR::LATCHING_SWITCH:
      return "Latching";
    case STOP_BUTTON_BEHAVIOR::MOMENTARY_SWITCH:
      return "Momentary";
    case STOP_BUTTON_BEHAVIOR::NOT_CONNECTED:
      return "Not connected";
    default:
      return nullptr;
  }
}

const char* name_for_gpioopt1(GPIOOPT1 option) {
  switch (option) {
    case GPIOOPT1::DEFAULT_OPT:
      return "WUP1 / WUP2";
    case GPIOOPT1::I2C_DISPLAY_SSD1306:
      return "I2C Display (SSD1306)";
    case GPIOOPT1::ESTOP_BMS_POWER:
      return "E-Stop / BMS Power";
    default:
      return nullptr;
  }
}

// Special unicode characters
const char* TRUE_CHAR_CODE = "\u2713";   //&#10003";
const char* FALSE_CHAR_CODE = "\u2715";  //&#10005";

// Optimized helper functions for common patterns
const char* checked_or_empty(bool b) { 
    return b ? "checked" : ""; 
}

const char* hidden_or_empty(bool condition) {
    return condition ? "" : "hidden";
}

// Static buffer for formatted numeric results (thread-safe for single-threaded use)
static char format_buffer[64];

// Handler function signature using std::function for flexibility
using SettingsHandler = std::function<const char*(BatteryEmulatorSettingsStore&)>;

// Optimized settings processor using hash table with std::string keys
const char* optimised_settings_processor(const String& var, BatteryEmulatorSettingsStore& settings) {
    // Static hash table - initialized once, using std::string keys which have built-in hash support
    static const std::unordered_map<std::string, SettingsHandler> handlers = {
        // String values (cached to avoid repeated getString calls)
        {"HOSTNAME", [](auto& s) -> const char* {
            static String cache;
            cache = s.getString("HOSTNAME", "");
            return cache.c_str();
        }},
        {"SSID", [](auto& s) -> const char* {
            static String cache;
            cache = s.getString("SSID", "");
            return cache.c_str();
        }},
        {"PASSWORD", [](auto& s) -> const char* {
            static String cache;
            cache = s.getString("PASSWORD", "");
            return cache.c_str();
        }},
        {"APPASSWORD", [](auto& s) -> const char* {
            static String cache;
            cache = s.getString("APPASSWORD", "123456789");
            return cache.c_str();
        }},
        {"APNAME", [](auto& s) -> const char* {
            static String cache;
            cache = s.getString("APNAME", "BatteryEmulator");
            return cache.c_str();
        }},
        {"MQTTSERVER", [](auto& s) -> const char* {
            static String cache;
            cache = s.getString("MQTTSERVER", "");
            return cache.c_str();
        }},
        {"MQTTUSER", [](auto& s) -> const char* {
            static String cache;
            cache = s.getString("MQTTUSER", "");
            return cache.c_str();
        }},
        {"MQTTPASSWORD", [](auto& s) -> const char* {
            static String cache;
            cache = s.getString("MQTTPASSWORD", "");
            return cache.c_str();
        }},
        {"MQTTTOPIC", [](auto& s) -> const char* {
            static String cache;
            cache = s.getString("MQTTTOPIC", "");
            return cache.c_str();
        }},
        {"MQTTOBJIDPREFIX", [](auto& s) -> const char* {
            static String cache;
            cache = s.getString("MQTTOBJIDPREFIX", "");
            return cache.c_str();
        }},
        {"MQTTDEVICENAME", [](auto& s) -> const char* {
            static String cache;
            cache = s.getString("MQTTDEVICENAME", "");
            return cache.c_str();
        }},
        {"HADEVICEID", [](auto& s) -> const char* {
            static String cache;
            cache = s.getString("HADEVICEID", "");
            return cache.c_str();
        }},

        // Boolean checkboxes - return static literals
        {"DBLBTR", [](auto& s) { return checked_or_empty(s.getBool("DBLBTR")); }},
        {"TRIBTR", [](auto& s) { return checked_or_empty(s.getBool("TRIBTR")); }},
        {"SOCESTIMATED", [](auto& s) { return checked_or_empty(s.getBool("SOCESTIMATED")); }},
        {"CNTCTRL", [](auto& s) { return checked_or_empty(s.getBool("CNTCTRL")); }},
        {"NCCONTACTOR", [](auto& s) { return checked_or_empty(s.getBool("NCCONTACTOR")); }},
        {"CNTCTRLDBL", [](auto& s) { return checked_or_empty(s.getBool("CNTCTRLDBL")); }},
        {"CNTCTRLTRI", [](auto& s) { return checked_or_empty(s.getBool("CNTCTRLTRI")); }},
        {"PWMCNTCTRL", [](auto& s) { return checked_or_empty(s.getBool("PWMCNTCTRL")); }},
        {"PERBMSRESET", [](auto& s) { return checked_or_empty(s.getBool("PERBMSRESET")); }},
        {"REMBMSRESET", [](auto& s) { return checked_or_empty(s.getBool("REMBMSRESET")); }},
        {"EXTPRECHARGE", [](auto& s) { return checked_or_empty(s.getBool("EXTPRECHARGE")); }},
        {"NOINVDISC", [](auto& s) { return checked_or_empty(s.getBool("NOINVDISC")); }},
        {"CANFDASCAN", [](auto& s) { return checked_or_empty(s.getBool("CANFDASCAN")); }},
        {"WIFIAPENABLED", [](auto& s) { return checked_or_empty(s.getBool("WIFIAPENABLED", wifiap_enabled)); }},
        {"STATICIP", [](auto& s) { return checked_or_empty(s.getBool("STATICIP")); }},
        {"PERFPROFILE", [](auto& s) { return checked_or_empty(s.getBool("PERFPROFILE")); }},
        {"CANLOGUSB", [](auto& s) { return checked_or_empty(s.getBool("CANLOGUSB")); }},
        {"USBENABLED", [](auto& s) { return checked_or_empty(s.getBool("USBENABLED")); }},
        {"WEBENABLED", [](auto& s) { return checked_or_empty(s.getBool("WEBENABLED")); }},
        {"CANLOGSD", [](auto& s) { return checked_or_empty(s.getBool("CANLOGSD")); }},
        {"SDLOGENABLED", [](auto& s) { return checked_or_empty(s.getBool("SDLOGENABLED")); }},
        {"MQTTENABLED", [](auto& s) { return checked_or_empty(s.getBool("MQTTENABLED")); }},
        {"MQTTTOPICS", [](auto& s) { return checked_or_empty(s.getBool("MQTTTOPICS")); }},
        {"MQTTCELLV", [](auto& s) { return checked_or_empty(s.getBool("MQTTCELLV")); }},
        {"HADISC", [](auto& s) { return checked_or_empty(s.getBool("HADISC")); }},
        {"PYLONOFFSET", [](auto& s) { return checked_or_empty(s.getBool("PYLONOFFSET")); }},
        {"PYLONORDER", [](auto& s) { return checked_or_empty(s.getBool("PYLONORDER")); }},
        {"INVICNT", [](auto& s) { return checked_or_empty(s.getBool("INVICNT")); }},
        {"DEYEBYD", [](auto& s) { return checked_or_empty(s.getBool("DEYEBYD")); }},
        {"INTERLOCKREQ", [](auto& s) { return checked_or_empty(s.getBool("INTERLOCKREQ")); }},
        {"DIGITALHVIL", [](auto& s) { return checked_or_empty(s.getBool("DIGITALHVIL")); }},
        {"GTWRHD", [](auto& s) { return checked_or_empty(s.getBool("GTWRHD")); }},

        // Network connection status variables for conditional HTML display
        {"WIFIENABLED", [](auto& s) { return wifi_enabled ? "true" : "false"; }},
        {"ETHERNETPRESENT", [](auto& s) { return ethernetPresent ? "true" : "false"; }},

        // Numeric values - use static buffer to avoid String allocation
        {"MAXPRETIME", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("MAXPRETIME", 15000));
            return format_buffer;
        }},
        {"WIFICHANNEL", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("WIFICHANNEL", 0));
            return format_buffer;
        }},
        {"CHGPOWER", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("CHGPOWER", 0));
            return format_buffer;
        }},
        {"DCHGPOWER", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("DCHGPOWER", 0));
            return format_buffer;
        }},
        
        // IP address components
        {"LOCALIP1", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("LOCALIP1", 0));
            return format_buffer;
        }},
        {"LOCALIP2", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("LOCALIP2", 0));
            return format_buffer;
        }},
        {"LOCALIP3", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("LOCALIP3", 0));
            return format_buffer;
        }},
        {"LOCALIP4", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("LOCALIP4", 0));
            return format_buffer;
        }},
        
        // Gateway components
        {"GATEWAY1", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("GATEWAY1", 0));
            return format_buffer;
        }},
        {"GATEWAY2", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("GATEWAY2", 0));
            return format_buffer;
        }},
        {"GATEWAY3", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("GATEWAY3", 0));
            return format_buffer;
        }},
        {"GATEWAY4", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("GATEWAY4", 0));
            return format_buffer;
        }},
        
        // Subnet components
        {"SUBNET1", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("SUBNET1", 0));
            return format_buffer;
        }},
        {"SUBNET2", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("SUBNET2", 0));
            return format_buffer;
        }},
        {"SUBNET3", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("SUBNET3", 0));
            return format_buffer;
        }},
        {"SUBNET4", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("SUBNET4", 0));
            return format_buffer;
        }},
        
        {"MQTTPORT", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("MQTTPORT", 1883));
            return format_buffer;
        }},
        {"MQTTTIMEOUT", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("MQTTTIMEOUT", 2000));
            return format_buffer;
        }},

        // Class visibility conditions - return static literals
        {"SAVEDCLASS", [](auto& s) { return hidden_or_empty(!settingsUpdated); }},
        {"BATTERY2CLASS", [](auto& s) { return hidden_or_empty(!battery2); }},
        {"INVCLASS", [](auto& s) { return hidden_or_empty(!inverter); }},
        {"INVBIDCLASS", [](auto& s) { return hidden_or_empty(!inverter || !inverter->supports_battery_id()); }},
        {"SHUNTCLASS", [](auto& s) { return hidden_or_empty(user_selected_shunt_type == ShuntType::None); }},
        {"CHARGERCLASS", [](auto& s) { return hidden_or_empty(!charger); }},
        {"MANUAL_BAL_CLASS", [](auto& s) { return hidden_or_empty(!(battery && battery->supports_manual_balancing())); }},
        {"FAKE_VOLTAGE_CLASS", [](auto& s) { return hidden_or_empty(!(battery && battery->supports_set_fake_voltage())); }},

        // Interface names - require runtime evaluation
        {"BATTERYINTF", [](auto& s) -> const char* {
            static String cache;
            if (battery) {
                cache = battery->interface_name();
                return cache.c_str();
            }
            return "";
        }},
        {"BATTERY2INTF", [](auto& s) -> const char* {
            static String cache;
            if (battery2) {
                cache = battery2->interface_name();
                return cache.c_str();
            }
            return "";
        }},
        {"INVINTF", [](auto& s) -> const char* {
            static String cache;
            if (inverter) {
                cache = inverter->interface_name();
                return cache.c_str();
            }
            return "";
        }},
        
        // Floating point values with fixed precision
        {"BATTPVMAX", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%.1f", 
                     static_cast<float>(s.getUInt("BATTPVMAX", 0)) / 10.0f);
            return format_buffer;
        }},
        {"BATTPVMIN", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%.1f", 
                     static_cast<float>(s.getUInt("BATTPVMIN", 0)) / 10.0f);
            return format_buffer;
        }},
        
        // Additional numeric settings
        {"BATTCVMAX", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("BATTCVMAX", 0));
            return format_buffer;
        }},
        {"BATTCVMIN", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("BATTCVMIN", 0));
            return format_buffer;
        }},
        {"SOFAR_ID", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("SOFAR_ID", 0));
            return format_buffer;
        }},
        {"PYLONSEND", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("PYLONSEND", 0));
            return format_buffer;
        }},
        {"INVCELLS", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("INVCELLS", 0));
            return format_buffer;
        }},
        {"INVMODULES", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("INVMODULES", 0));
            return format_buffer;
        }},
        {"INVCELLSPER", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("INVCELLSPER", 0));
            return format_buffer;
        }},
        {"INVVLEVEL", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("INVVLEVEL", 0));
            return format_buffer;
        }},
        {"INVCAPACITY", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("INVCAPACITY", 0));
            return format_buffer;
        }},
        {"INVBTYPE", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("INVBTYPE", 0));
            return format_buffer;
        }},
        {"CANFREQ", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("CANFREQ", 8));
            return format_buffer;
        }},
        {"CANFDFREQ", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("CANFDFREQ", 40));
            return format_buffer;
        }},
        {"PRECHGMS", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("PRECHGMS", 100));
            return format_buffer;
        }},
        {"PWMFREQ", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("PWMFREQ", 20000));
            return format_buffer;
        }},
        {"PWMHOLD", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", s.getUInt("PWMHOLD", 250));
            return format_buffer;
        }},

        // Runtime-evaluated variables from datalayer (not stored in settings)
        {"BATTERY_WH_MAX", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%u", datalayer.battery.info.total_capacity_Wh);
            return format_buffer;
        }},
        {"MAX_CHARGE_SPEED", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%.1f", datalayer.battery.settings.max_user_set_charge_dA / 10.0f);
            return format_buffer;
        }},
        {"MAX_DISCHARGE_SPEED", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%.1f", datalayer.battery.settings.max_user_set_discharge_dA / 10.0f);
            return format_buffer;
        }},
        {"SOC_MAX_PERCENTAGE", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%.1f", datalayer.battery.settings.max_percentage / 100.0f);
            return format_buffer;
        }},
        {"SOC_MIN_PERCENTAGE", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%.1f", datalayer.battery.settings.min_percentage / 100.0f);
            return format_buffer;
        }},
        {"CHARGE_VOLTAGE", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%.1f", datalayer.battery.settings.max_user_set_charge_voltage_dV / 10.0f);
            return format_buffer;
        }},
        {"DISCHARGE_VOLTAGE", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%.1f", datalayer.battery.settings.max_user_set_discharge_voltage_dV / 10.0f);
            return format_buffer;
        }},
        {"SOC_SCALING_ACTIVE_CLASS", [](auto& s) { 
            return datalayer.battery.settings.soc_scaling_active ? "active" : "inactive"; 
        }},
        {"VOLTAGE_LIMITS_ACTIVE_CLASS", [](auto& s) { 
            return datalayer.battery.settings.user_set_voltage_limits_active ? "active" : "inactive"; 
        }},
        {"SOC_SCALING_CLASS", [](auto& s) { 
            return datalayer.battery.settings.soc_scaling_active ? "active" : "inactiveSoc"; 
        }},
        {"SOC_SCALING", [](auto& s) { 
            return datalayer.battery.settings.soc_scaling_active ? TRUE_CHAR_CODE : FALSE_CHAR_CODE; 
        }},
        {"VOLTAGE_LIMITS", [](auto& s) { 
            return datalayer.battery.settings.user_set_voltage_limits_active ? TRUE_CHAR_CODE : FALSE_CHAR_CODE; 
        }},
        {"BATTERY_VOLTAGE", [](auto& s) -> const char* {
            if (battery) {
                snprintf(format_buffer, sizeof(format_buffer), "%.1f", battery->get_voltage());
                return format_buffer;
            }
            return "";
        }},
        {"MANUAL_BALANCING", [](auto& s) { 
            return datalayer.battery.settings.user_requests_balancing ? TRUE_CHAR_CODE : FALSE_CHAR_CODE; 
        }},
        {"MANUAL_BALANCING_CLASS", [](auto& s) { 
            return datalayer.battery.settings.user_requests_balancing ? "" : "inactiveSoc"; 
        }},
        {"BALANCING_CLASS", [](auto& s) { 
            return datalayer.battery.settings.user_requests_balancing ? "active" : "inactive"; 
        }},
        {"BAL_MAX_TIME", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%.1f", datalayer.battery.settings.balancing_time_ms / 60000.0f);
            return format_buffer;
        }},
        {"BAL_POWER", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%.0f", datalayer.battery.settings.balancing_float_power_W / 1.0f);
            return format_buffer;
        }},
        {"BAL_MAX_PACK_VOLTAGE", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%.0f", datalayer.battery.settings.balancing_max_pack_voltage_dV / 10.0f);
            return format_buffer;
        }},
        {"BAL_MAX_CELL_VOLTAGE", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%.0f", datalayer.battery.settings.balancing_max_cell_voltage_mV / 1.0f);
            return format_buffer;
        }},
        {"BAL_MAX_DEV_CELL_VOLTAGE", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%.0f", datalayer.battery.settings.balancing_max_deviation_cell_voltage_mV / 1.0f);
            return format_buffer;
        }},
        {"BMS_RESET_DURATION", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%.0f", datalayer.battery.settings.user_set_bms_reset_duration_ms / 1000.0f);
            return format_buffer;
        }},

        // Charger variables
        {"CHG_HV_CLASS", [](auto& s) { 
            return datalayer.charger.charger_HV_enabled ? "active" : "inactiveSoc"; 
        }},
        {"CHG_HV", [](auto& s) { 
            return datalayer.charger.charger_HV_enabled ? TRUE_CHAR_CODE : FALSE_CHAR_CODE; 
        }},
        {"CHG_AUX12V_CLASS", [](auto& s) { 
            return datalayer.charger.charger_aux12V_enabled ? "active" : "inactiveSoc"; 
        }},
        {"CHG_AUX12V", [](auto& s) { 
            return datalayer.charger.charger_aux12V_enabled ? TRUE_CHAR_CODE : FALSE_CHAR_CODE; 
        }},
        {"CHG_VOLTAGE_SETPOINT", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%.1f", datalayer.charger.charger_setpoint_HV_VDC);
            return format_buffer;
        }},
        {"CHG_CURRENT_SETPOINT", [](auto& s) -> const char* {
            snprintf(format_buffer, sizeof(format_buffer), "%.1f", datalayer.charger.charger_setpoint_HV_IDC);
            return format_buffer;
        }},

        // Special case - INVBID is runtime dependent
        {"INVBID", [](auto& s) -> const char* {
            if (inverter && inverter->supports_battery_id()) {
                snprintf(format_buffer, sizeof(format_buffer), "%u", datalayer.battery.settings.sofar_user_specified_battery_id);
                return format_buffer;
            }
            return "";
        }}
    };

    // Convert Arduino String to std::string for hash table lookup
    std::string key = var.c_str();
    auto it = handlers.find(key);
    if (it != handlers.end()) {
        return it->second(settings);
    }
    
    return "";  // Default empty string for unknown variables
    
}

String raw_settings_processor(const String& var, BatteryEmulatorSettingsStore& settings) {
    return String(optimised_settings_processor(var, settings));
}

String settings_processor(const String& var, BatteryEmulatorSettingsStore& settings) {
  // HTML-ready values (such as select options) are returned here. These don't
  // get any additional escaping.

  if (var == "SHUNTCOMM") {
    return options_for_enum((comm_interface)settings.getUInt("SHUNTCOMM", (int)comm_interface::CanNative),
                            name_for_comm_interface);
  }

  if (var == "BATTTYPE") {
    return options_for_enum_with_none((BatteryType)settings.getUInt("BATTTYPE", (int)BatteryType::None),
                                      name_for_battery_type, BatteryType::None);
  }
  if (var == "BATTCOMM") {
    return options_for_enum((comm_interface)settings.getUInt("BATTCOMM", (int)comm_interface::CanNative),
                            name_for_comm_interface);
  }
  if (var == "BATTCHEM") {
    return options_for_enum(
        (battery_chemistry_enum)settings.getUInt("BATTCHEM", (int)battery_chemistry_enum::Autodetect),
        name_for_chemistry);
  }
  if (var == "INVTYPE") {
    return options_for_enum_with_none(
        (InverterProtocolType)settings.getUInt("INVTYPE", (int)InverterProtocolType::None), name_for_inverter_type,
        InverterProtocolType::None);
  }
  if (var == "INVCOMM") {
    return options_for_enum((comm_interface)settings.getUInt("INVCOMM", (int)comm_interface::CanNative),
                            name_for_comm_interface);
  }
  if (var == "CHGTYPE") {
    return options_for_enum_with_none((ChargerType)settings.getUInt("CHGTYPE", (int)ChargerType::None),
                                      name_for_charger_type, ChargerType::None);
  }
  if (var == "CHGCOMM") {
    return options_for_enum((comm_interface)settings.getUInt("CHGCOMM", (int)comm_interface::CanNative),
                            name_for_comm_interface);
  }

  if (var == "SHUNTTYPE") {
    return options_for_enum_with_none((ShuntType)settings.getUInt("SHUNTTYPE", (int)ShuntType::None),
                                      name_for_shunt_type, ShuntType::None);
  }

  if (var == "SHUNTCOMM") {
    return options_for_enum((comm_interface)settings.getUInt("SHUNTCOMM", (int)comm_interface::CanNative),
                            name_for_comm_interface);
  }

  if (var == "EQSTOP") {
    return options_for_enum_with_none(
        (STOP_BUTTON_BEHAVIOR)settings.getUInt("EQSTOP", (int)STOP_BUTTON_BEHAVIOR::NOT_CONNECTED),
        name_for_button_type, STOP_BUTTON_BEHAVIOR::NOT_CONNECTED);
  }

  if (var == "BATT2COMM") {
    return options_for_enum((comm_interface)settings.getUInt("BATT2COMM", (int)comm_interface::CanNative),
                            name_for_comm_interface);
  }

  if (var == "BATT3COMM") {
    return options_for_enum((comm_interface)settings.getUInt("BATT3COMM", (int)comm_interface::CanNative),
                            name_for_comm_interface);
  }

  if (var == "GTWCOUNTRY") {
    return options_from_map(settings.getUInt("GTWCOUNTRY", 0), tesla_countries);
  }

  if (var == "GTWMAPREG") {
    return options_from_map(settings.getUInt("GTWMAPREG", 0), tesla_mapregion);
  }

  if (var == "GTWCHASSIS") {
    return options_from_map(settings.getUInt("GTWCHASSIS", 0), tesla_chassis);
  }

  if (var == "GTWPACK") {
    return options_from_map(settings.getUInt("GTWPACK", 0), tesla_pack);
  }

  if (var == "LEDMODE") {
    return options_from_map(settings.getUInt("LEDMODE", 0), led_modes);
  }

  if (var == "GPIOOPT1") {
    return options_for_enum_with_none((GPIOOPT1)settings.getUInt("GPIOOPT1", (int)GPIOOPT1::DEFAULT_OPT),
                                      name_for_gpioopt1, GPIOOPT1::DEFAULT_OPT);
  }

  // All other values are wrapped by html_escape to avoid HTML injection.

  return html_escape(raw_settings_processor(var, settings));
}



const char* getCANInterfaceName(CAN_Interface interface) {
  switch (interface) {
    case CAN_NATIVE:
      return "CAN";
    case CANFD_NATIVE:
      if (use_canfd_as_can) {
        return "CAN-FD Native (Classic CAN)";
      } else {
        return "CAN-FD Native";
      }
    case CAN_ADDON_MCP2515:
      return "Add-on CAN via GPIO MCP2515";
    case CANFD_ADDON_MCP2518:
      if (use_canfd_as_can) {
        return "Add-on CAN-FD via GPIO MCP2518 (Classic CAN)";
      } else {
        return "Add-on CAN-FD via GPIO MCP2518";
      }
    default:
      return "UNKNOWN";
  }
}

// Runtime GPIO setting generation - replaces compile-time #ifdef
String getGpioOpt1Setting() {
#ifdef HW_LILYGO2CAN
  return R"rawliteral(
    <label for="GPIOOPT1">Configurable port:</label>
    <select id="GPIOOPT1" name="GPIOOPT1">
      %GPIOOPT1%
    </select>
  )rawliteral";
#else
  return "";
#endif
}

// Function to process conditional content in HTML files
// Use markers like /*#ifdef HW_LILYGO2CAN*/ and /*#endif*/ in your HTML files
// String processConditionalContent(const String& content) {
//   String result = content;

// #ifdef HW_LILYGO2CAN
//   // Keep HW_LILYGO2CAN sections, remove others
//   result.replace("/*#ifdef HW_LILYGO2CAN*/", "");

//   // Remove content between /*#ifndef HW_LILYGO2CAN*/ and /*#endif*/
//   int start = 0;
//   while ((start = result.indexOf("/*#ifndef HW_LILYGO2CAN*/", start)) != -1) {
//     int end = result.indexOf("/*#endif*/", start);
//     if (end != -1) {
//       result.remove(start, end - start + 10);
//     } else {
//       break;
//     }
//   }

//   result.replace("/*#endif*/", "");
// #else
//   // Keep default sections, remove HW_LILYGO2CAN sections
//   result.replace("/*#ifndef HW_LILYGO2CAN*/", "");

//   // Remove content between /*#ifdef HW_LILYGO2CAN*/ and /*#endif*/
//   int start = 0;
//   while ((start = result.indexOf("/*#ifdef HW_LILYGO2CAN*/", start)) != -1) {
//     int end = result.indexOf("/*#endif*/", start);
//     if (end != -1) {
//       result.remove(start, end - start + 10);
//     } else {
//       break;
//     }
//   }

//   result.replace("/*#endif*/", "");
// #endif

//   return result;
// }

String getSettingsHtmlScripts() {
  String content = readFileFromLittleFS("/settings_scripts.html");
  //return processConditionalContent(content);
  return content;
}

String getSettingsStyle() {
  String content = readFileFromLittleFS("/settings_style.html");
  //return processConditionalContent(content);
  return content;
}

String getSettingsHtmlBody() {
  String content = readFileFromLittleFS("/settings_body.html");

  // Process conditional content
  //content = processConditionalContent(content);

  // Replace the %GPIOOPT1_SETTING% placeholder with runtime-generated content
  content.replace("%GPIOOPT1_SETTING%", getGpioOpt1Setting());

  return content;
}

// Function to build complete settings HTML from LittleFS files
String buildSettingsHtml() {
  String html = INDEX_HTML_HEADER;
  html += COMMON_JAVASCRIPT;
  html += getSettingsStyle();
  html += getSettingsHtmlBody();
  html += getSettingsHtmlScripts();
  html += INDEX_HTML_FOOTER;

  return html;
}

// Legacy const char* for compatibility - will be built dynamically
String settings_html_string;
const char* settings_html = nullptr;
